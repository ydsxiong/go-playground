package lead

import (
	"encoding/json"
	"fmt"
	"io"
	"os"
	"sync"
	"time"
)

/**
auto rewind it to the top every time new data gets written back into the file
*/
type Tape struct {
	fd *os.File
}

func (t *Tape) Write(b []byte) (int, error) {
	t.fd.Truncate(0)
	t.fd.Seek(0, 0)
	return t.fd.Write(b)
}

func NewTapeFile(fd *os.File) *Tape {
	return &Tape{fd}
}

type fileSystemStore struct {
	leads     Leads
	fdEncoder *json.Encoder
	mux       sync.RWMutex
}

func LoadUpFileStore(filestorepath string) (*fileSystemStore, func(), error) {
	fd, err := os.OpenFile(filestorepath, os.O_RDWR|os.O_CREATE, 0666)
	if err != nil {
		return nil, nil, fmt.Errorf("problem opening %s %v", filestorepath, err)
	}
	closeFunc := func() {
		fd.Close()
	}

	store, err := NewFileSystemStore(fd)
	if err != nil {
		return nil, nil, fmt.Errorf("Problem with opening file database, %v", err)
	}

	return store, closeFunc, nil
}

func initialiseStoreFile(fd *os.File) error {
	fd.Seek(0, 0)

	info, err := fd.Stat()
	if err != nil {
		return fmt.Errorf("problem getting file info from file %s, %v", fd.Name(), err)
	}

	if info.Size() == 0 {
		fd.Write([]byte("[]"))
		fd.Seek(0, 0)
	}

	return nil
}

func NewFileSystemStore(fd *os.File) (*fileSystemStore, error) {

	e := initialiseStoreFile(fd)
	if e != nil {
		return nil, fmt.Errorf("problem initialising data store file, %v", e)
	}

	leads, err := newSetOfLeads(fd)
	if err != nil {
		return nil, fmt.Errorf("problem loading data store from file %s, %v", fd.Name(), err)
	}

	store := &fileSystemStore{
		leads:     leads,
		fdEncoder: json.NewEncoder(NewTapeFile(fd))}

	// auto refresh the new file contents into the web server, as the file can be updated from another external source.
	ticker := time.NewTicker(2 * time.Minute)
	go func() {
		for _ = range ticker.C {
			leads, err := newSetOfLeads(fd)
			if err == nil {
				store.leads = leads
			}
		}
	}()
	return store, nil
}

/**
in the context of database store, these two fields: id and createdAt
would have been generated by the database insert operation.
*/
func (fs *fileSystemStore) Save(lead Lead) error {
	fs.mux.Lock()
	defer fs.mux.Unlock()

	lead.ID = uint(len(fs.leads) + 1)
	lead.CreatedAt = time.Now()

	fs.leads = append(fs.leads, lead)
	fs.fdEncoder.Encode(fs.leads)
	return nil
}

func (fs *fileSystemStore) FindAll() (Leads, error) {
	fs.mux.RLock()
	defer fs.mux.RUnlock()
	return fs.leads.FindAll(), nil
}

func (fs *fileSystemStore) FindByEmail(email string) (*Lead, error) {
	fs.mux.RLock()
	defer fs.mux.RUnlock()
	return fs.leads.FindByEmail(email), nil
}

func newSetOfLeads(data io.ReadSeeker) (leads Leads, err error) {
	data.Seek(0, 0)
	var l []Lead
	err = json.NewDecoder(data).Decode(&l)
	if err != nil {
		err = fmt.Errorf("problem parsing league, %v", err)
		leads = nil
	} else {
		// only when the file is successfully loaded would we then want to replace the old store in memory
		leads = Leads(l)
		leads.Sort()
	}
	return
}
